You have seen that relational database requires to divide information into columns and rows -- this gives us
tables with records as a result. A record in such a table has a given structure. Sometimes there is a need to store
related information into multiple tables -- there can be many reasons for that:

- Records are naturally separable by common reasoning or by application design needs
  (e.g. product images are stored in another table than the products themselves).
- Record in one table can be shared by records in other tables (e.g. an address can be shared
  among many persons whom happen to live in the same building or an address can be shared by a person
  and also can be used as a meeting location).
- Other technical reasons -- mostly defined by
  [database normalization rules](/articles/database-design/#database-normalization) which
  should be obeyed during the [database structure design process](/articles/database-design/).

Records are then connected by [foreign keys](/articles/relational-database/#foreign-key) which
contain information about relationships between tables.

Let's think about a simple scenario based on your
[database structure](/course/#project-assignment) -- you want to create a form, where the users
of your application could fill (in a single step) the information about a person and information about the address of this person. This is quite helpful because users do not need to create the address record beforehand.

In your database schema, you have the table `person` and the table `location`. After the examination of columns in these two
tables you find out that the table `person` has the column `id_address` which also has a defined
[foreign key](/articles/relational-database/#foreign-key) pointing into the table `location`.
This means that in the `person` table you can define a link for each record to the `location` table using the value from
the column `id_location` of the table `location`. This also means that multiple persons can share one address (imagine that
they live in one household as a family).

Because te person links to the address, you have to insert information about the address first. Then
somehow find the ID assigned to that new row (remember that it is [auto-generated](/walkthrough/database/#insert)), store the ID in local variable of the script.
Then you can insert the the row with person information which will include the ID of the new address.
The only problem is how to find the auto-generated ID.

## Concurrency Problems
If you work with the database alone (when you develop an application), the state of the database does not change unless
you do something. In a real world situation, there can be many other users changing the database through your application
at any moment. This basically means that you cannot `INSERT` the data and then `SELECT` e.g. the highest ID from the table.
The problem is that many other users' `INSERT` commands could be executed between your `INSERT` and your `SELECT MAX()...` command. You have to ask the database system specifically for ID of
[last insertion in **in your session**](/articles/database-tech/#currval--lastinsertid-or-max). Session is
basically a connection between your application and the SQL server. Session is initiated during the startup of
your application.

For this purpose the database [has a mechanism](/articles/database-tech/#automatically-generated-key) which will return the last ID generated by an auto-increment
**sequence** requested by **your** `INSERT` in **your** database session. In Postgre SQL, each auto-increment sequence
has a name -- you can find that name in the default value of the *id* column:

{: .image-popup}
![Screenshot - Sequence Name](/common/backend-insert/sequence-name.png)

There is a [`CURRVAL(seq_name)`](/articles/database-tech/#auto-increment-in-postgresql) SQL function which will return the last value of the auto-increment sequence in Postgre SQL and
this function takes as an argument the name of the sequence. Execute both commands at once in the Adminer:

{% highlight sql %}
{% include /common/backend-insert/advanced1.sql %}
{% endhighlight %}

Now you can search for the record with the returned ID -- you should find a row with the `city` column set to `Bucharest`.
Notice that these two queries have to be executed in a single execution and therefore they have to be separated by a semicolon.

## PHP Code
In PHP with the PDO library you can use the `lastInsertId($sequenceName)` method instead of executing separate SQL SELECT
command: