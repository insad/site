---
title: User authentication - login
permalink: /en/apv/walkthrough/login/
---

* TOC
{:toc}

This chapter is about means to protect your application from anonymous users who could deliberately
delete random data or pollute your application with spam messages. Until now, your application was publicly 
available to online audience without any possibility to control who is working with stored data.
I want to show you how to store user account data securely (especially passwords) and how to verify
(authenticate) a user which is trying to log into your application. I will not talk about different levels
of user permissions because it would complicate things a lot -- such feature is called authorisation.

## Storing user's passwords
It is not a safe approach to store passwords in their plain-text form. Such passwords can be viewed by anybody
who has access to your database (maybe now it is only you, but in future it can be some of your colleagues or
even your employees). A password is always saved in hashed form (a *hash* is a result of function which outputs
a unique strings for different inputs and it is not trivial to reverse this process -- i.e. to calculate original
password from a hash).

Examples of hash function outputs in PHP for word "cat":

- [md5](http://php.net/manual/en/function.md5.php)('cat') =
  d077f244def8a70e5ea758bd8352fcd8 (always 32 characters)
- [sha1](http://php.net/manual/en/function.sha1.php)('cat') =
  9d989e8d27dc9e0ec3389fc855f142c3d40f0c50 (always 40 characters)
- [password_hash](http://php.net/manual/en/function.password-hash.php)('cat') =
  $2y$10$5iA8dvLAzWzl.cepri1xxuINCQBHKNANmEfx4nT/jjCV4hWcUTW.y (up to 255 characters according to selected hashing algorithm)
 
{: .note}
Function password_hash() is a bit different because its output is not always same like with the md5 or
sha1 functions. It is caused by a *salt* which is a sequence of random characters. The *salt* is used to make
hashes unique to avoid attackers from searching hashes online or using vocabulary attacks (try to
search for md5 hash **e246c559bf94965d89cf207fc45905bc** using [Google](http://www.google.com?q=e246c559bf94965d89cf207fc45905bc) --
[d'oh](https://en.wikipedia.org/wiki/D'oh!)). A salt is stored directly in the result of password_hash() function.
To verify a password generated by password_hash() use [password_verify()](http://php.net/manual/en/function.password-verify.php)
function.

{: .note.note-cont}
You can also use a salt with the md5 or sha1 but you have to handle it by yourself (you will need another column in
your database table to store it).

### Task -- try to calculate hash with random salt and verify it
To store a password during registration process:

    hash = sha1(randomSalt + registrationPassword)

To verify a password when user tries to log-in (first fetch hash and salt from database):
    
    if(sha1(databaseSalt + providedPassword) == databaseHash) {...OK...}

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/hash-salt.php %}
{% endhighlight %}

{: .note}
The probability that concatenation of user's password and a random string used as a salt
will yield results in vocabulary search is very small. Yet use of sha1() or md5() functions
is strongly discouraged because powerful CPUs or GPUs can generate millions of hashes per second and
they are capable of breaking md5 or sha1 hashes within reasonable time (days). Recommended function
password_hash() is also quiet slow (by design -- this is one of few instances when we want our
algorithms to be slow).

{: .note}
One of the reasons why any web application sends you a new password instead of yours when you forgot
it, is hashing. They do not store your password in plain text form.

### Task -- create a table to store user data in database
Create a table with login or email column and a column to store password in hashed format.
If you plan to use password_hash() function, you do not need another column for salt.
Remember that login or email column must have unique constraint to prevent duplicate user accounts.

{: .solution}
{% highlight sql %}
{% include /en/apv/walkthrough/login/account-table.sql %}
{% endhighlight %}

## Registration process
Registration is actually not very much different from any other record insertion. Only difference is
that you have to validate match of the passwords and calculate the hash. After successful insertion of
the account record redirect the visitor to the login page.

### Task -- create a form for user registration
It should have an input for login or email and two inputs for password verification (all inputs are required).
You can use [Bootstrap](/en/apv/walkthrough/css/bootstrap) CSS styles.

File `register.latte`:

{: .solution}
{% highlight html %}
{% include /en/apv/walkthrough/login/templates/register.latte %}
{% endhighlight %}

### Task -- process registration with PHP script
Use [password_hash()](http://php.net/manual/en/function.password-hash.php) function. Read the documentation
because this function requires actually two input parameters. Second one is the algorithm which is used for
password hash calculation.

File `register.php`:

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/register.php %}
{% endhighlight %}

After successful registration, a record representing user account in the database should look like this:

![User account in database](account-in-db.png)

## User verification and login
User verification is also not a big problem -- a person who wishes to log-in into your application has to visit
login page with a simple two-input form. After he fills and submits the form, he is verified against the database.
If an existing account is found and passwords match, your application can trust this user.

{: .note}
Actually there were cases when a user logged into another user's account by a mistake -- two different accounts had
same passwords (not even salt can solve this situation). There are also online identity thefts when user's password
is compromised and used by someone else to harm original person. You can add another tier of user authentication,
e.g. send an SMS to his cell phone to retype a verification code or distribute user [certificates](TODO).

### Task -- create a form for user login with PHP script
Create a login form and a PHP script to process login information. You can make error message a bit confusing to
obfuscate existence of user accounts (sometimes you do not wish to easily reveal users of your app -- especially when
you use email address as login). For now, do not bother yourself by the fact that the confirmation is displayed only when
the user sends his credentials. We will handle persistence of authentication flag later.

File `login.latte`:

{: .solution}
{% highlight html %}
{% include /en/apv/walkthrough/login/templates/login.latte %}
{% endhighlight %}

File `login.php`:

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/login-first.php %}
{% endhighlight %}

## Persisting data between HTTP requests - $_SESSION
You probably noticed that there is no way to tell if a user has authenticated in subsequent HTTP requests due to stateless
nature of [HTTP protocol](/en/apv/articles/web/#http-protocol). To safely store login information you would probably
want to logically connect subsequent HTTP request from one client (internet browser) and associate these requests with
some kind of server storage. That is exactly what [*sessions*](/en/apv/articles/cookies-sessions#sessions) are used for. A session
is a server-side storage which is individual for each client. Client holds only unique key to this storage on its side
(stored in [cookies](/en/apv/articles/cookies-sessions#cookies)). Client is responsible for sending this key with every HTTP
request. If the client "forgets" the key, data stored in session is lost. The key is actually called *session ID*.

To initiate work with session storage you have to call PHP function [`session_start()`](http://php.net/manual/en/function.session-start.php)
in the beginning of each of your script (before you send any output, because `session_start()` sends a cookie via
HTTP headers).

In PHP, there is as superglobal `$_SESSION` array which is used to hold various data between HTTP request. These
data are stored on a server and cannot be modified by will of a visitor -- it has to be done by your application's
code. The `$_SESSION` variable is initialized and eventually filled by `session_start()` function.

### Task -- store information about authenticated user
Use `$_SESSION` variable to store authenticated user's data after login. Insert line with `session_start();` function
into start.php script.

File `login.php` (final version):

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/login.php %}
{% endhighlight %}

Extended file `start.php`:

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/include/start.php %}
{% endhighlight %}

## Preventing unauthenticated users from performing actions
You can prevent anonymous users to access all your application's functions or just selected ones. If a visitor
tries to access prohibited function without authentication, he should be redirected to the login page.

### Task -- protect your application
Write a short include-script which will verify presence of user's data in `$_SESSION` array and redirect to login.php
script if no such data is found. Require this script in all PHP scripts where **you want user authentication to be 
performed** before execution of that script itself. Place the require command just below the line where you require
start.php script.

File `protect.php`:

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/include/protect.php %}
{% endhighlight %}

Here is an example how to protect [deletion](/en/apv/walkthrough/backend-delete) of persons from database
with created script:

File `delete.php`:

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/delete.php %}
{% endhighlight %}

{: .note}
You can also pass information about authenticated user into templates in `protect.php` script. This would be useful
to modify your templates according to the presence of selected variable -- e.g. you can show or hide menu buttons
which are not accessible to anonymous user. If you choose to make some modules of your application public, you should
pass user related variables in another way because `protect.php` is not always executed. You can do that in `start.php`
after you start the session. Remember to handle non-existing values (for the case that the user is not logged in yet).

## Logout
Finally, we have to give our users an option to leave our application. A logout action is usually just deletion of
all user related data from `$_SESSION` variable on server.
 
{: .note}
Sometimes you wish to leave some data in the `$_SESSION` variable -- the contents of shopping cart, for example.

### Task -- Create a logout script
Use [`session_destroy()`](http://php.net/manual/en/function.session-destroy.php) function. Redirect user to public
page of your application after logout. Put logout button to your layout.latte template.

File `logout.php`:

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/logout.php %}
{% endhighlight %}

Make a link to logout script from main menu. You can display user's login name inside the link.

## Conclusion
User authentication or even authorisation is complicated. I demonstrated one of the easiest ways how to do it --
you can also hardcode passwords into your source code (do not do that!). Keep in mind that weakest point of
application is probably its user because people are lazy to fabricate new passwords for each website and they share
some passwords with their family or friends. Security measures should also be designed according to the type
of application you are developing (a bank account management application VS discussion board).

Passwords are sent over the network in plain text, it is a good idea to use HTTPS for (at least) registration and
login pages to prevent attackers to sniff the password from network traffic. Still this does not prevent targeting
users of your application by scam login pages which are used to steal their authentication information.

There is a lot more to explore: you probably know sites where you can persist your authentication for duration of days
or even weeks -- ours is forgotten as soon as the visitor closes his browser's window. That can be achieved by setting
special attributes to cookies which hold keys to a sessions. You also probably seen that some sites use global services
like Facebook or Google to provide login functionality, which is good for users who do not want to remember too many
passwords. Totally [different approach](https://jwt.io/) of authentication is used for [single page applications](/en/apv/walkthrough/javascript/).

Remember that you are responsible for security of your application and also for the data of your users.

### New Concepts and Terms
- authentication
- hash & salt
- $_SESSION
- login
- logout