---
title: Login 
permalink: /en/apv/walkthrough/login/
---

* TOC
{:toc}

# User authentication -- login
This chapter is about means to protect your application from anonymous users who could deliberately
delete random data or pollute your application with spam messages. Until now, your application was publicly 
available to online audience without any possibility to control who is working with stored data.
I want to show you how to store user account data securely (especially passwords) and how to verify
(authenticate) a user which is trying to log into your application. I will not talk about different levels
of user permissions because it would complicate things a lot -- such feature is called authorisation.

## Storing user's passwords
It is not a safe approach to store passwords in their plain-text form. Such passwords can be viewed by anybody
who has access to your database (maybe now it is only you, but in future it can be some of your colleagues or
even your employees). A password is always saved in hashed form (a *hash* is a result of function which outputs
unique strings for different inputs and it is not trivial to reverse this process -- i.e. to calculate original
password from hash).

Examples of hash function outputs in PHP for word "cat":

- [md5](http://php.net/manual/en/function.md5.php)('cat') =
  d077f244def8a70e5ea758bd8352fcd8 (always 32 characters)
- [sha1](http://php.net/manual/en/function.sha1.php)('cat') =
  9d989e8d27dc9e0ec3389fc855f142c3d40f0c50 (always 40 characters)
- [password_hash](http://php.net/manual/en/function.password-hash.php)('cat') =
  $2y$10$5iA8dvLAzWzl.cepri1xxuINCQBHKNANmEfx4nT/jjCV4hWcUTW.y (up to 255 characters according to selected hashing algorithm)
 
<div class="note">
    <p markdown="1">
        Function password_hash() is a bit different because its output is not always same like with md5 or
        sha1 functions. It is caused by **salt** which is sequence of random characters. Salt is used to make
        hashes unique to avoid attackers from searching hashes online or using vocabulary attacks (try to
        search for md5 hash **e246c559bf94965d89cf207fc45905bc** using [Google](http://google.com?q=e246c559bf94965d89cf207fc45905bc) --
        [d'oh](https://en.wikipedia.org/wiki/D'oh!)). Salt is stored directly in result of password_hash().
        To verify a password generated by password_hash() use [password_verify()](http://php.net/manual/en/function.password-verify.php)
        function.
    </p>
    <p>
        You can also use salt with md5 and sha1 but you have to handle it by yourself (you will need another column in
        your database table to store it).
    </p>
    
</div>

### Task -- try to calculate hash with random salt and verify it
To store a password during registration process:

    hash = sha1(randomSalt + registrationPassword)

To verify a password when user tries to log-in (first fetch hash and salt from database):
    
    if(sha1(databaseSalt + providedPassword) == databaseHash) {...OK...}

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/hash-salt.php %}
{% endhighlight %}

{: .note}
The probability that concatenation of user's password and a random string used as a salt
will yield results in vocabulary search is very small. Yet use of sha1() or md5() functions
is strongly discouraged because powerful CPUs or GPUs can generate millions of hashes per second and
they are capable of breaking md5 or sha1 hashes within reasonable time (days). Recommended function
password_hash() is also quiet slow (by design -- this is one of few instances when we want our
algorithms to be slow).

{: .note}
One of the reasons why any web application sends you a new password instead of yours when you forgot
it is hashing. They do not store your password in plain text form.

### Task -- create a table to store user data in database
Create a table with login or email column and a column to store password in hashed format.
If you plan to use password_hash() function, you do not need another column for salt.
Remember that login or email column must have unique constraint.

{: .solution}
{% highlight sql %}
{% include /en/apv/walkthrough/login/account-table.sql %}
{% endhighlight %}

## Registration process
Registration is actually not very much different from any other record insertion. Only difference is
that you have to validate match of the passwords and calculate hash. After successful insertion of
account record redirect visitor to login page.

### Task -- create a form for user registration
It should have an input for login or email and two inputs for passwords (all inputs are required).
You can use [Bootstrap](/en/apv/walkthrough/css/bootstrap) CSS styles.

register.latte:

{: .solution}
{% highlight html %}
{% include /en/apv/walkthrough/login/templates/register.latte %}
{% endhighlight %}

### Task -- process registration with PHP script
Use [password_hash()](http://php.net/manual/en/function.password-hash.php) function. Read the documentation
because this function requires actually two input parameters. Second one is algorithm which is used for password
calculation.

register.php:

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/register.php %}
{% endhighlight %}

## User verification and login
User verification is also not a big problem -- a person who wish to log-in into your application has to visit
login page with simple form. After he fills and submits the form, he is verified against database. If an existing
account is found and passwords match, your application can trust this user.

{: .note}
Actually there were cases when a user logged into another user's account by a mistake -- two different accounts had
same passwords (not even salt can solve this situation). There are also online identity thefts when user's password
is compromised and used by someone else to harm original person. You can add another tier of user authentication,
e.g. send an SMS to his cell phone to retype verification code.

### Task -- create a form for user login with PHP script
Create a login form and a PHP script to process login information. You can make error message a bit confusing to
obfuscate existence of user accounts (sometimes you do not wish to easily reveal users of your app -- especially when
you use email address as login). Do not bother yourself by the fact that the confirmation is displayed only when
user sends his credentials for now. We will handle persistence of authentication flag later.

login.latte:

{: .solution}
{% highlight html %}
{% include /en/apv/walkthrough/login/templates/login.latte %}
{% endhighlight %}

login.php:

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/login-first.php %}
{% endhighlight %}

## Persisting data between HTTP requests - $_SESSION
You probably noticed that there is no way to tell if a user has authenticated in subsequent HTTP requests due to stateless
nature of HTTP protocol. To safely store login information you would probably want to logically connect subsequent HTTP
request from one client (internet browser) and associate these requests with some kind of server storage. That is exactly
what *sessions* are used for. A session is server side storage which is individual for each client. Client holds only
unique key to this storage on its side (stored in [cookies](TODO)). Client is responsible for sending this key with
every HTTP request. If the client "forgots" the key, data stored in session is lost. The key is actually called
*session ID*.

To initiate work with session storage you have to call PHP function [session_start()](http://php.net/manual/en/function.session-start.php)
in the beginning of your script (before you send any output, because session_start() sends a cookie via HTTP headers).

In PHP, there is as superglobal $_SESSION array which is used to hold various data between HTTP request. These
data are stored on server and cannot be modified by will of a visitor -- it has to be done by your application's code.

### Task -- store information about authenticated user
Use $_SESSION variable to store authenticated user's data after login. Insert line with `session_start();` function
into start.php script.

login.php (final version):

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/login.php %}
{% endhighlight %}

extended start.php:

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/include/start.php %}
{% endhighlight %}

## Preventing unauthenticated users from performing actions
You can prevent anonymous users to access all your application's functions or just selected ones. If a visitor
tries to access prohibited function without authentication, he should be redirected to login page.

### Task -- protect your application
Write a short include-script which will verify presence of user's data in $_SESSION array and redirect to login.php
script if no such data is found. Require this script to all PHP scripts where **you want user authentication to be 
performed** before execution of script itself. Place the require command just below the line where you require
start.php script.

protect.php:

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/include/protect.php %}
{% endhighlight %}

Here is an example how to protect [deletion](/en/apv/walkthrough/backend-delete) of persons from database with created script:

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/delete.php %}
{% endhighlight %}

## Logout
Finally, we have to give our users an option to leave application. A logout action is usually just deletion of
all user related data from $_SESSION variable on server. 

### Task -- Create a logout script
Use [session_destroy()](http://php.net/manual/en/function.session-destroy.php) function. Redirect user to public
page of your application after logout. Put logout button to your layout.latte template.

logout.php:

{: .solution}
{% highlight php %}
{% include /en/apv/walkthrough/login/logout.php %}
{% endhighlight %}

## Conclusion
User authentication or even authorisation is complicated. I demonstrated one of the easiest ways how to do it --
you can also hardcode passwords into your source code (do not do that!). Keep in mind that weakest point of
application is probably its user because people are lazy to fabricate new passwords for each website and they share
some passwords with their family or friends. Security measures should also be designed according to the type
of application you are developing (a bank account management application VS discussion board).

Passwords are sent over the network in plain text, it is a good idea to use HTTPS for registration and login pages
to prevent attackers to sniff the password from network traffic.

There is a lot more to explore: you probably know sites where you can persist your authentication for duration of days
or even weeks -- ours is forgotten as soon as the visitor closes his browser's window. That can be achieved by setting
special attributes to cookies which hold keys to sessions. You also probably seen that some sites use global services
like Facebook or Google to provide login functionality, which is good for users who do not want to remember too many
passwords. Totally [different approach](https://jwt.io/) of authentication is used for single page applications (SPA).

Remember that you are responsible for security of your application and also for the data of your users.

### New Concepts and Terms
- hash & salt
- $_SESSION